'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _cloneDeep = require('lodash/cloneDeep');

var _cloneDeep2 = _interopRequireDefault(_cloneDeep);

var _isEqual = require('lodash/isEqual');

var _isEqual2 = _interopRequireDefault(_isEqual);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Transform operations `a` by operations `b` with `priority`.
 *
 * @param {Array} a
 * @param {Array} b
 * @param {String} priority
 */

function transform(a, b, priority) {
  // Deeply clone A so that the transformers can edit in place without worry.
  a = (0, _cloneDeep2.default)(a);

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = b[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var bo = _step.value;

      // Create a temporary array to store the new A operations, because sometimes
      // the transformers need to return `null` to remove an operation, or return
      // an array to add operations.
      var tmp = [];

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = a[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var ao = _step2.value;

          var ret = t(ao, bo, priority);

          if (ret === null) {
            continue;
          } else if (Array.isArray(ret)) {
            tmp = tmp.concat(ret);
          } else {
            tmp.push(ao);
          }
        }

        // Update A for the next iteration.
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      a = tmp;
    }

    // Return the transformed A operations.
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return a;
}

/**
 * Find the place where path `a` is intersected by path `b`, if it does.
 *
 * @param {Array} a
 * @param {Array} b
 * @return {String|Null}
 */

function intersectPath(a, b) {
  if (a == null || b == null) return null;

  for (var i = 0; i < b.length; i++) {
    var bv = b[i];
    var av = a[i];
    var al = i + 1 === a.length;
    var bl = i + 1 === b.length;
    // If ever `bv > av`, `b` doesn't intersect `a`.
    if (bv > av) return 'none';
    // If we're not at the end of `b`, and `bv < av`, `b` doesn't intersect `a`.
    if (!bl && bv < av) return 'none';
    // If at the end of both, and `bv == av`, `b` is exactly equal to `a`.
    if (al && bl && bv == av) return 'exact';
    // If only at the end of `b`, and `bv == av`, `b` is above `a`.
    if (bl && bv == av) return 'above';
    // If at the end of `b`, and `bv < av`, `b` is before `a`.
    if (bl && bv < av) return 'before';
  }

  return 'none';
}

/**
 * Find the place where `a`'s offset `a` is intersected by operation B's
 * offset `b`, if it does at all.
 *
 * @param {Number} a
 * @param {Number} b
 * @return {String}
 */

function intersectOffset(a, b) {
  if (a == null || b == null) return null;
  if (b < a) return 'before';
  if (b == a) return 'exact';
  return 'after';
}

/**
 * Transform operation `a` in place based on operation `b` and priority `p`.
 *
 * @param {Object} a
 * @param {Object} b
 * @param {String} p
 */

function t(a, b, p) {
  var i = b.path.length - 1;
  var ni = b.newPath ? b.newPath.length - 1 : null;

  var ap_bp = intersectPath(a.path, b.path);
  var ap_bnp = intersectPath(a.path, b.newPath);
  var anp_bp = intersectPath(a.newPath, b.path);
  var anp_bnp = intersectPath(a.newPath, b.newPath);
  var awp_bp = intersectPath(a.withPath, b.path);
  var ap_bwp = intersectPath(a.path, b.withPath);

  var ao_bo = intersectOffset(a.offset, b.offset);
  var ao_bol = intersectOffset(a.offset, b.offset + b.length);
  var aol_bo = intersectOffset(a.offset + a.length, b.offset);
  var aol_bol = intersectOffset(a.offset + a.length, b.offset + b.length);

  /**
   * Insert node.
   */

  if (b.type == 'insert_node') {
    // If A is a `join_node` operation, and B's path intersects A's exactly, a
    // node was inserted between where the join was supposed to happen, so we
    // add an extra `move_node` operation to keep the join from failing.
    if (a.type == 'join_node' && ap_bp == 'exact') {
      var newPath = a.path.slice();
      var path = newPath.slice(0, -1).concat([newPath[i] + 1]);
      var move = { type: 'move_node', path: path, newPath: newPath };
      return [move, a];
    }

    // If B's path intersects before, above, or exactly at A's path, increment
    // A's path to account for the inserted node. If operation A is an
    // `insert_node` operation, check for priority to maintain ordering.
    if (ap_bp == 'before' || ap_bp == 'above' || ap_bp == 'exact' && a.type != 'insert_node' || ap_bp == 'exact' && a.type == 'insert_node' && p == 'right') {
      a.path[i]++;
      if (a.withPath) a.withPath[i]++;
    }

    // If B's path intersects before or above A's new path, or exactly at it
    // with priority, increment A's new path to account for the inserted node.
    if (anp_bp == 'before' || anp_bp == 'above' || anp_bp == 'exact' && p == 'right') {
      a.newPath[i]++;
    }
  }

  /**
   * Remove node.
   */

  if (b.type == 'remove_node') {
    // If A is a `join_node` operation, and B's path intersects exactly with one
    // of A's paths, one of the join targets was already removed, so remove the
    // other one as well.
    if (a.type == 'join_node' && (ap_bp == 'exact' || awp_bp == 'exact')) {
      var _path = ap_bp == 'exact' ? a.withPath.slice() : a.path.slice();
      var remove = { type: 'remove_node', path: _path };
      return [remove];
    }

    // If B's path intersects exactly at A's path, and operation A is not an
    // `insert_node` operation, ignore operation A because the node it is
    // targeting has already been removed.
    if (a.type != 'insert_node' && ap_bp == 'exact') {
      return null;
    }

    // If B's path intersects above of A's, ignore operation A because the
    // target has already been removed.
    if (ap_bp == 'above') {
      return null;
    }

    // If B's path intersects before A's, decrement A's to account for the
    // earlier node's removal.
    if (ap_bp == 'before') {
      a.path[i]--;
      if (a.withPath) a.withPath[i]--;
    }

    // If B's path intersects before A's `newPath`, decrement A's `newPath` to
    // account for the earlier node's removal.
    if (anp_bp == 'before') {
      a.newPath[i]--;
    }
  }

  /**
   * Join node.
   */

  if (b.type == 'join_node') {
    // If A is a `join_node` operation, and B's path intersects A's path
    // exactly, then ignore operation A.
    if (a.type == 'join_node' && ap_bp == 'exact') {
      return null;
    }

    // If A is an `insert_node` operation, and B's path intersects exactly with
    // A's, do nothing, because the insert path won't be affected.
    if (a.type == 'insert_node' && ap_bp == 'exact') {
      return;
    }

    // If A is a `remove_node` operation, and B's `withPath` intersects with
    // A's, then the removal target was already joined with another node, and we
    // need to remove the combined result node instead.
    if (ap_bp == 'exact') {
      a.path = b.withPath.slice();
    }

    // If B's path is before A's, decrement A's to account for the join.
    if (ap_bp == 'before' || ap_bp == 'above') {
      a.path[i]--;
      if (a.withPath) a.withPath[i]--;
    }

    // If B's path is before A's `newPath`, decrement A's `newPath` to account
    // for the join.
    if (anp_bp == 'before' || anp_bp == 'above') {
      a.newPath[i]--;
    }
  }

  /**
   * Insert text.
   */

  if (b.type == 'insert_text') {
    // If operation B's path doesn't exactly intersect with A's, then the text
    // insertion won't have any effect on it.
    if (ap_bp != 'exact') {
      return;
    }

    // If A is an operation with an `offset`, but not an `insert_text`
    // operation, and B's `offset` intersects after it, and B's `offset` is less
    // than A's range, A's range will be split where B intersects it
    // into two operations.
    if (ao_bo == 'after' && a.type != 'insert_text' && b.offset < a.offset + a.length) {
      var one = _extends({}, a, { length: b.offset });
      var two = _extends({}, a, { offset: b.offset + b.text.length, length: a.length - b.offset });
      return [one, two];
    }

    // If B's offset intersects before A's, or at the same index as A's but with
    // priority, or exactly at A's but A is not an `insert_text` operation,
    // increment A's offset to account for the inserted text.
    if (ao_bo == 'before' || ao_bo == 'exact' && p == 'right' || ao_bo == 'exact' && a.type != 'insert_text') {
      a.offset += b.text.length;
    }
  }

  /**
   * Remove text.
   */

  if (b.type == 'remove_text') {
    // If operation B's path doesn't exactly intersect with A's, then the text
    // removal won't have any effect on it.
    if (ap_bp != 'exact') {
      return;
    }

    // If A is an `insert_text` operation, and if B's offset intersects befores
    // A's, decrement A's offset to account for the removed text.
    if (a.type == 'insert_text' && ao_bo == 'before') {
      var _remove = Math.min(a.offset, b.length);
      a.offset -= _remove;
    }

    // If A is not an `insert_text` operation, and B's `offset` intersects
    // before A's `offset`, decrement A's `offset` by the number of characters
    // removed before it, and A's `length` by the characters removed that
    // overlap it.
    if (a.type != 'insert_text' && ao_bo == 'before') {
      var decrement = Math.min(b.length, a.offset - b.offset);
      var _remove2 = Math.min(a.length, b.length - decrement);
      a.offset -= decrement;
      a.length -= _remove2;
    }

    // If A is not an `insert_text` operation, and B intersects is exactly,
    // decrement A's `length` by B's `length` since that text is already
    // removed.
    if (a.type != 'insert_text' && ao_bo == 'exact') {
      var _remove3 = Math.min(a.length, b.length);
      a.length -= _remove3;
    }

    // If A is not an `insert_text` operation, and B's `offset` intersects after
    // A's `offset`, decrement A's `length` by any overlapping characters that
    // have already been removed.
    if (a.type != 'insert_text' && ao_bo == 'after') {
      var diff = b.offset - a.offset;
      var overlap = Math.max(0, Math.min(b.length, a.length - diff));
      var _remove4 = Math.min(a.length, overlap);
      a.length -= _remove4;
    }

    // If A is not an `insert_text` operation, and after adjusting A's `offset`
    // and `length`, its `length` is zero, ignore A since it does nothing.
    if (a.type != 'insert_text' && ao_bo != null && a.length == 0) {
      return null;
    }
  }

  /**
   * Add mark.
   */

  if (b.type == 'add_mark') {
    // If B's path doesn't intersect A's exactly, or either operation has no
    // `offset`, or B doesn't have priority, or the operations's `mark` don't
    // match, then B can't affect A, so abort.
    if (ap_bp != 'exact' || ao_bo == null || p != 'right' || !(0, _isEqual2.default)(a.mark, b.mark)) {
      return;
    }

    // If A is an `remove_mark` operation, and B's start intersects before A's,
    // shift A to omit the range removed by B.
    if (a.type == 'remove_mark' && ao_bo == 'before') {
      var skip = Math.min(b.length, a.offset - b.offset);
      var omit = Math.min(a.length, b.length - skip);
      a.offset += skip;
      a.length -= omit;
    }

    // If A is an `remove_mark` operation, and B's start intersects exactly at
    // A's, shift A to omit the range removed by B.
    if (a.type == 'remove_mark' && ao_bo == 'exact') {
      var _omit = Math.min(a.length, b.length);
      a.offset += _omit;
      a.length -= _omit;
    }

    // If A is an `remove_mark` operation, and B's start intersects after A's,
    // and B's end intersects before A's, we need to split A into two operations
    // since B removes the mark in the middle.
    if (a.type == 'remove_mark' && ao_bo == 'after' && aol_bol == 'before') {
      var before = b.offset - a.offset;
      var after = a.length - before - b.length;
      var middle = a.length - before - after;
      var _one = _extends({}, a, { length: before });
      var _two = _extends({}, a, { offset: a.offset + before + middle, length: after });
      return [_one, _two];
    }

    // If A is an `remove_mark` operation, and B's start intersects after A's,
    // remove the overlaping region from A.
    if (a.type == 'remove_mark' && ao_bo == 'after') {
      var _diff = b.offset - a.offset;
      var _overlap = Math.max(0, Math.min(b.length, a.length - _diff));
      var _remove5 = Math.min(a.length, _overlap);
      a.length -= _remove5;
    }

    // If A is an `remove_mark` operation, and its `length` is now zero, remove
    // it because it will have no effect.
    if (a.type == 'remove_mark' && a.length == 0) {
      return null;
    }
  }

  /**
   * Remove mark.
   */

  if (b.type == 'remove_mark') {
    // If B's path doesn't intersect A's exactly, or either operation has no
    // `offset`, or B doesn't have priority, or the operations's `mark` don't
    // match, then B can't affect A, so abort.
    if (ap_bp != 'exact' || ao_bo == null || p != 'right' || !(0, _isEqual2.default)(a.mark, b.mark)) {
      return;
    }

    // If A is an `add_mark` operation, and B's start intersects before A's,
    // shift A to omit the range removed by B.
    if (a.type == 'add_mark' && ao_bo == 'before') {
      var _skip = Math.min(b.length, a.offset - b.offset);
      var _omit2 = Math.min(a.length, b.length - _skip);
      a.offset += _skip;
      a.length -= _omit2;
    }

    // If A is an `add_mark` operation, and B's start intersects exactly at A's,
    // shift A to omit the range removed by B.
    if (a.type == 'add_mark' && ao_bo == 'exact') {
      var _omit3 = Math.min(a.length, b.length);
      a.offset += _omit3;
      a.length -= _omit3;
    }

    // If A is an `add_mark` operation, and B's start intersects after A's,
    // and B's end intersects before A's, we need to split A into two operations
    // since B removes the mark in the middle.
    if (a.type == 'add_mark' && ao_bo == 'after' && aol_bol == 'before') {
      var _before = b.offset - a.offset;
      var _after = a.length - _before - b.length;
      var _middle = a.length - _before - _after;
      var _one2 = _extends({}, a, { length: _before });
      var _two2 = _extends({}, a, { offset: a.offset + _before + _middle, length: _after });
      return [_one2, _two2];
    }

    // If A is an `add_mark` operation, and B's start intersects after A's,
    // remove the overlaping region from A.
    if (a.type == 'add_mark' && ao_bo == 'after') {
      var _diff2 = b.offset - a.offset;
      var _overlap2 = Math.max(0, Math.min(b.length, a.length - _diff2));
      var _remove6 = Math.min(a.length, _overlap2);
      a.length -= _remove6;
    }

    // If A is an `add_mark` operation, and its `length` is now zero, remove it
    // because it will have no effect.
    if (a.type == 'add_mark' && a.length == 0) {
      return null;
    }
  }

  /**
   * Move node.
   */

  if (b.type == 'move_node') {
    // If A is also a `move_node` operation, and their paths are exactly equal,
    // and B has priority, then remove A because it "lost".
    if (a.type == 'move_node' && ap_bp == 'exact' && p == 'right') {
      return null;
    }

    // If B's old path is exactly A's, change A's path to where B moved it to.
    if (ap_bp == 'exact') {
      a.path = b.newPath;
    }

    // If B's old path is exactly A's `newPath`, change A's `newPath` to where B
    // moved it to.
    if (anp_bp == 'exact') {
      a.newPath = b.newPath;
    }

    // If B's old path intersects above A's, change A's path to reflect where B
    // moved it to.
    if (ap_bp == 'above') {
      a.path = b.newPath.concat(a.path.slice(b.newPath.length));
    }

    // If B's old path intersects above A's `newPath`, change A's `newPath` to
    // reflect where B moved it to.
    if (anp_bp == 'above') {
      a.newPath = b.newPath.concat(a.newPath.slice(b.newPath.length));
    }

    // If B's old path intersects before A's, and its new path interects after
    // or exactly at A's, decrement A's path to account for the move.
    if (ap_bp == 'before' && (ap_bnp == 'none' || ap_bnp == 'exact' || ap_bnp == 'above')) {
      a.path[i]--;
      if (a.withPath) a.withPath[i]--;
    }

    // If B's old path intersects before A's `newPath`, and B's `newPath`
    // interects after or exactly at A's `newPath`, decrement A's `newPath` to
    // account for the move.
    if (anp_bp == 'before' && ap_bp != 'exact' && (anp_bnp == 'none' || anp_bnp == 'exact' || anp_bnp == 'above')) {
      a.newPath[i]--;
    }

    // If B's old path intersects before A's, and its new path intersects before
    // or exactly at A's, increment A's path to account for the move.
    if (ap_bp == 'none' && (ap_bnp == 'before' || ap_bnp == 'exact' || anp_bnp == 'above')) {
      a.path[ni]++;
      if (a.withPath) a.withPath[ni]++;
    }

    // If B's old path intersects before A's `newPath`, and B's `newPath`
    // intersects before or exactly at A's `newPath`, increment A's `newPath` to
    // account for the move.
    if (anp_bp == 'none' && (anp_bnp == 'before' || anp_bnp == 'exact' || anp_bnp == 'above')) {
      a.newPath[ni]++;
    }

    return;

    // If A is a `join_node` operation, and B's path intersected either one of
    // A's paths, then ignore A since the nodes are no longer adjacent.
    if (a.type == 'join_node' && (ap_bp == 'exact' || awp_bp == 'exact') && p == 'right') {
      return null;
    }

    // If A has a `newPath`, and `b.path` intersects at `a.path`, and `b` has
    // priority, and `b.newPath` doesn't intersect, decrement.
    if (anp_bp == 'exact' && p == 'right' && anp_bnp == 'none') {
      a.newPath[i]--;
    }
  }

  // /**
  //  * Split node.
  //  */

  // if (b.type == 'split_node') {
  //   // If `b.path` intersects before `a.path`, increment.
  //   if (ap_bp == 'before') {
  //     a.path[i]++
  //     if (a.withPath) a.withPath[i]++
  //   }

  //   // If `b.path` intersects at `a.path`, and `b` has priority, and `a` is a
  //   // `remove_node` operation, then ignore `a`.
  //   if (a.type == 'remove_node' && ap_bp == 'same' && p == 'right') {
  //     return null
  //   }

  //   // If `b.path` intersects at `a.path`, and `b` has priority, and `a` is a
  //   // `split_node` operation, then increment `a.path` and decrement `a.offset`.
  //   if (a.type == 'split_node' && ap_bp == 'same' && p == 'right') {
  //     a.path[i]++
  //     a.offset -= b.offset
  //   }

  //   // If `b.path` intersects at `a.path`, and `b` has priority, increment
  //   // `a.path`.
  //   if (ap_bp == 'same' && p == 'right') {
  //     a.path[i]++
  //     if (a.withPath) a.withPath[i]++
  //   }

  //   // If `b.path` intersects at `a.path`, and `b` has priority, and A is a
  //   // `remove_node` operation, then ignore A.
  //   if (a.type == 'remove_node' && awp_bp == 'same' && p == 'right') {
  //     return null
  //   }

  //   // If A has a `newPath`, and `b.path` intersects before `a.path`, increment A's
  //   // path.
  //   if (anp_bp == 'before') {
  //     a.newPath[i]++
  //   }

  //   // If `b.path` intersects at `a.newPath`, and `b` has priority, increment
  //   // `a.newPath`.
  //   if (anp_bp == 'same' && p == 'right') {
  //     a.newPath[i]++
  //   }
  // }
}

/**
 * Export.
 *
 * @type {Function}
 */

exports.default = transform;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9vdC90cmFuc2Zvcm0uanMiXSwibmFtZXMiOlsidHJhbnNmb3JtIiwiYSIsImIiLCJwcmlvcml0eSIsImJvIiwidG1wIiwiYW8iLCJyZXQiLCJ0IiwiQXJyYXkiLCJpc0FycmF5IiwiY29uY2F0IiwicHVzaCIsImludGVyc2VjdFBhdGgiLCJpIiwibGVuZ3RoIiwiYnYiLCJhdiIsImFsIiwiYmwiLCJpbnRlcnNlY3RPZmZzZXQiLCJwIiwicGF0aCIsIm5pIiwibmV3UGF0aCIsImFwX2JwIiwiYXBfYm5wIiwiYW5wX2JwIiwiYW5wX2JucCIsImF3cF9icCIsIndpdGhQYXRoIiwiYXBfYndwIiwiYW9fYm8iLCJvZmZzZXQiLCJhb19ib2wiLCJhb2xfYm8iLCJhb2xfYm9sIiwidHlwZSIsInNsaWNlIiwibW92ZSIsInJlbW92ZSIsIm9uZSIsInR3byIsInRleHQiLCJNYXRoIiwibWluIiwiZGVjcmVtZW50IiwiZGlmZiIsIm92ZXJsYXAiLCJtYXgiLCJtYXJrIiwic2tpcCIsIm9taXQiLCJiZWZvcmUiLCJhZnRlciIsIm1pZGRsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQTs7Ozs7Ozs7QUFRQSxTQUFTQSxTQUFULENBQW1CQyxDQUFuQixFQUFzQkMsQ0FBdEIsRUFBeUJDLFFBQXpCLEVBQW1DO0FBQ2pDO0FBQ0FGLE1BQUkseUJBQVVBLENBQVYsQ0FBSjs7QUFGaUM7QUFBQTtBQUFBOztBQUFBO0FBSWpDLHlCQUFpQkMsQ0FBakIsOEhBQW9CO0FBQUEsVUFBVEUsRUFBUzs7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsVUFBSUMsTUFBTSxFQUFWOztBQUprQjtBQUFBO0FBQUE7O0FBQUE7QUFNbEIsOEJBQWlCSixDQUFqQixtSUFBb0I7QUFBQSxjQUFUSyxFQUFTOztBQUNsQixjQUFNQyxNQUFNQyxFQUFFRixFQUFGLEVBQU1GLEVBQU4sRUFBVUQsUUFBVixDQUFaOztBQUVBLGNBQUlJLFFBQVEsSUFBWixFQUFr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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEOztBQUVEOzs7Ozs7a0JBTWVkLFMiLCJmaWxlIjoidHJhbnNmb3JtLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgY2xvbmVEZWVwIGZyb20gJ2xvZGFzaC9jbG9uZURlZXAnXG5pbXBvcnQgaXNFcXVhbCBmcm9tICdsb2Rhc2gvaXNFcXVhbCdcblxuLyoqXG4gKiBUcmFuc2Zvcm0gb3BlcmF0aW9ucyBgYWAgYnkgb3BlcmF0aW9ucyBgYmAgd2l0aCBgcHJpb3JpdHlgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFcbiAqIEBwYXJhbSB7QXJyYXl9IGJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmlvcml0eVxuICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybShhLCBiLCBwcmlvcml0eSkge1xuICAvLyBEZWVwbHkgY2xvbmUgQSBzbyB0aGF0IHRoZSB0cmFuc2Zvcm1lcnMgY2FuIGVkaXQgaW4gcGxhY2Ugd2l0aG91dCB3b3JyeS5cbiAgYSA9IGNsb25lRGVlcChhKVxuXG4gIGZvciAoY29uc3QgYm8gb2YgYikge1xuICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBhcnJheSB0byBzdG9yZSB0aGUgbmV3IEEgb3BlcmF0aW9ucywgYmVjYXVzZSBzb21ldGltZXNcbiAgICAvLyB0aGUgdHJhbnNmb3JtZXJzIG5lZWQgdG8gcmV0dXJuIGBudWxsYCB0byByZW1vdmUgYW4gb3BlcmF0aW9uLCBvciByZXR1cm5cbiAgICAvLyBhbiBhcnJheSB0byBhZGQgb3BlcmF0aW9ucy5cbiAgICBsZXQgdG1wID0gW11cblxuICAgIGZvciAoY29uc3QgYW8gb2YgYSkge1xuICAgICAgY29uc3QgcmV0ID0gdChhbywgYm8sIHByaW9yaXR5KVxuXG4gICAgICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmV0KSkge1xuICAgICAgICB0bXAgPSB0bXAuY29uY2F0KHJldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRtcC5wdXNoKGFvKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBBIGZvciB0aGUgbmV4dCBpdGVyYXRpb24uXG4gICAgYSA9IHRtcFxuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSB0cmFuc2Zvcm1lZCBBIG9wZXJhdGlvbnMuXG4gIHJldHVybiBhXG59XG5cbi8qKlxuICogRmluZCB0aGUgcGxhY2Ugd2hlcmUgcGF0aCBgYWAgaXMgaW50ZXJzZWN0ZWQgYnkgcGF0aCBgYmAsIGlmIGl0IGRvZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYVxuICogQHBhcmFtIHtBcnJheX0gYlxuICogQHJldHVybiB7U3RyaW5nfE51bGx9XG4gKi9cblxuZnVuY3Rpb24gaW50ZXJzZWN0UGF0aChhLCBiKSB7XG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gbnVsbFxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJ2ID0gYltpXVxuICAgIGNvbnN0IGF2ID0gYVtpXVxuICAgIGNvbnN0IGFsID0gaSArIDEgPT09IGEubGVuZ3RoXG4gICAgY29uc3QgYmwgPSBpICsgMSA9PT0gYi5sZW5ndGhcbiAgICAvLyBJZiBldmVyIGBidiA+IGF2YCwgYGJgIGRvZXNuJ3QgaW50ZXJzZWN0IGBhYC5cbiAgICBpZiAoYnYgPiBhdikgcmV0dXJuICdub25lJ1xuICAgIC8vIElmIHdlJ3JlIG5vdCBhdCB0aGUgZW5kIG9mIGBiYCwgYW5kIGBidiA8IGF2YCwgYGJgIGRvZXNuJ3QgaW50ZXJzZWN0IGBhYC5cbiAgICBpZiAoIWJsICYmIGJ2IDwgYXYpIHJldHVybiAnbm9uZSdcbiAgICAvLyBJZiBhdCB0aGUgZW5kIG9mIGJvdGgsIGFuZCBgYnYgPT0gYXZgLCBgYmAgaXMgZXhhY3RseSBlcXVhbCB0byBgYWAuXG4gICAgaWYgKGFsICYmIGJsICYmIGJ2ID09IGF2KSByZXR1cm4gJ2V4YWN0J1xuICAgIC8vIElmIG9ubHkgYXQgdGhlIGVuZCBvZiBgYmAsIGFuZCBgYnYgPT0gYXZgLCBgYmAgaXMgYWJvdmUgYGFgLlxuICAgIGlmIChibCAmJiBidiA9PSBhdikgcmV0dXJuICdhYm92ZSdcbiAgICAvLyBJZiBhdCB0aGUgZW5kIG9mIGBiYCwgYW5kIGBidiA8IGF2YCwgYGJgIGlzIGJlZm9yZSBgYWAuXG4gICAgaWYgKGJsICYmIGJ2IDwgYXYpIHJldHVybiAnYmVmb3JlJ1xuICB9XG5cbiAgcmV0dXJuICdub25lJ1xufVxuXG4vKipcbiAqIEZpbmQgdGhlIHBsYWNlIHdoZXJlIGBhYCdzIG9mZnNldCBgYWAgaXMgaW50ZXJzZWN0ZWQgYnkgb3BlcmF0aW9uIEInc1xuICogb2Zmc2V0IGBiYCwgaWYgaXQgZG9lcyBhdCBhbGwuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gaW50ZXJzZWN0T2Zmc2V0KGEsIGIpIHtcbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBudWxsXG4gIGlmIChiIDwgYSkgcmV0dXJuICdiZWZvcmUnXG4gIGlmIChiID09IGEpIHJldHVybiAnZXhhY3QnXG4gIHJldHVybiAnYWZ0ZXInXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIG9wZXJhdGlvbiBgYWAgaW4gcGxhY2UgYmFzZWQgb24gb3BlcmF0aW9uIGBiYCBhbmQgcHJpb3JpdHkgYHBgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICogQHBhcmFtIHtTdHJpbmd9IHBcbiAqL1xuXG5mdW5jdGlvbiB0KGEsIGIsIHApIHtcbiAgY29uc3QgaSA9IGIucGF0aC5sZW5ndGggLSAxXG4gIGNvbnN0IG5pID0gYi5uZXdQYXRoID8gYi5uZXdQYXRoLmxlbmd0aCAtIDEgOiBudWxsXG5cbiAgY29uc3QgYXBfYnAgPSBpbnRlcnNlY3RQYXRoKGEucGF0aCwgYi5wYXRoKVxuICBjb25zdCBhcF9ibnAgPSBpbnRlcnNlY3RQYXRoKGEucGF0aCwgYi5uZXdQYXRoKVxuICBjb25zdCBhbnBfYnAgPSBpbnRlcnNlY3RQYXRoKGEubmV3UGF0aCwgYi5wYXRoKVxuICBjb25zdCBhbnBfYm5wID0gaW50ZXJzZWN0UGF0aChhLm5ld1BhdGgsIGIubmV3UGF0aClcbiAgY29uc3QgYXdwX2JwID0gaW50ZXJzZWN0UGF0aChhLndpdGhQYXRoLCBiLnBhdGgpXG4gIGNvbnN0IGFwX2J3cCA9IGludGVyc2VjdFBhdGgoYS5wYXRoLCBiLndpdGhQYXRoKVxuXG4gIGNvbnN0IGFvX2JvID0gaW50ZXJzZWN0T2Zmc2V0KGEub2Zmc2V0LCBiLm9mZnNldClcbiAgY29uc3QgYW9fYm9sID0gaW50ZXJzZWN0T2Zmc2V0KGEub2Zmc2V0LCBiLm9mZnNldCArIGIubGVuZ3RoKVxuICBjb25zdCBhb2xfYm8gPSBpbnRlcnNlY3RPZmZzZXQoYS5vZmZzZXQgKyBhLmxlbmd0aCwgYi5vZmZzZXQpXG4gIGNvbnN0IGFvbF9ib2wgPSBpbnRlcnNlY3RPZmZzZXQoYS5vZmZzZXQgKyBhLmxlbmd0aCwgYi5vZmZzZXQgKyBiLmxlbmd0aClcblxuICAvKipcbiAgICogSW5zZXJ0IG5vZGUuXG4gICAqL1xuXG4gIGlmIChiLnR5cGUgPT0gJ2luc2VydF9ub2RlJykge1xuICAgIC8vIElmIEEgaXMgYSBgam9pbl9ub2RlYCBvcGVyYXRpb24sIGFuZCBCJ3MgcGF0aCBpbnRlcnNlY3RzIEEncyBleGFjdGx5LCBhXG4gICAgLy8gbm9kZSB3YXMgaW5zZXJ0ZWQgYmV0d2VlbiB3aGVyZSB0aGUgam9pbiB3YXMgc3VwcG9zZWQgdG8gaGFwcGVuLCBzbyB3ZVxuICAgIC8vIGFkZCBhbiBleHRyYSBgbW92ZV9ub2RlYCBvcGVyYXRpb24gdG8ga2VlcCB0aGUgam9pbiBmcm9tIGZhaWxpbmcuXG4gICAgaWYgKGEudHlwZSA9PSAnam9pbl9ub2RlJyAmJiBhcF9icCA9PSAnZXhhY3QnKSB7XG4gICAgICBjb25zdCBuZXdQYXRoID0gYS5wYXRoLnNsaWNlKClcbiAgICAgIGNvbnN0IHBhdGggPSBuZXdQYXRoLnNsaWNlKDAsIC0xKS5jb25jYXQoW25ld1BhdGhbaV0gKyAxXSlcbiAgICAgIGNvbnN0IG1vdmUgPSB7IHR5cGU6ICdtb3ZlX25vZGUnLCBwYXRoLCBuZXdQYXRoIH1cbiAgICAgIHJldHVybiBbbW92ZSwgYV1cbiAgICB9XG5cbiAgICAvLyBJZiBCJ3MgcGF0aCBpbnRlcnNlY3RzIGJlZm9yZSwgYWJvdmUsIG9yIGV4YWN0bHkgYXQgQSdzIHBhdGgsIGluY3JlbWVudFxuICAgIC8vIEEncyBwYXRoIHRvIGFjY291bnQgZm9yIHRoZSBpbnNlcnRlZCBub2RlLiBJZiBvcGVyYXRpb24gQSBpcyBhblxuICAgIC8vIGBpbnNlcnRfbm9kZWAgb3BlcmF0aW9uLCBjaGVjayBmb3IgcHJpb3JpdHkgdG8gbWFpbnRhaW4gb3JkZXJpbmcuXG4gICAgaWYgKFxuICAgICAgKGFwX2JwID09ICdiZWZvcmUnKSB8fFxuICAgICAgKGFwX2JwID09ICdhYm92ZScpIHx8XG4gICAgICAoYXBfYnAgPT0gJ2V4YWN0JyAmJiBhLnR5cGUgIT0gJ2luc2VydF9ub2RlJykgfHxcbiAgICAgIChhcF9icCA9PSAnZXhhY3QnICYmIGEudHlwZSA9PSAnaW5zZXJ0X25vZGUnICYmIHAgPT0gJ3JpZ2h0JylcbiAgICApIHtcbiAgICAgIGEucGF0aFtpXSsrXG4gICAgICBpZiAoYS53aXRoUGF0aCkgYS53aXRoUGF0aFtpXSsrXG4gICAgfVxuXG4gICAgLy8gSWYgQidzIHBhdGggaW50ZXJzZWN0cyBiZWZvcmUgb3IgYWJvdmUgQSdzIG5ldyBwYXRoLCBvciBleGFjdGx5IGF0IGl0XG4gICAgLy8gd2l0aCBwcmlvcml0eSwgaW5jcmVtZW50IEEncyBuZXcgcGF0aCB0byBhY2NvdW50IGZvciB0aGUgaW5zZXJ0ZWQgbm9kZS5cbiAgICBpZiAoXG4gICAgICAoYW5wX2JwID09ICdiZWZvcmUnKSB8fFxuICAgICAgKGFucF9icCA9PSAnYWJvdmUnKSB8fFxuICAgICAgKGFucF9icCA9PSAnZXhhY3QnICYmIHAgPT0gJ3JpZ2h0JylcbiAgICApIHtcbiAgICAgIGEubmV3UGF0aFtpXSsrXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBub2RlLlxuICAgKi9cblxuICBpZiAoYi50eXBlID09ICdyZW1vdmVfbm9kZScpIHtcbiAgICAvLyBJZiBBIGlzIGEgYGpvaW5fbm9kZWAgb3BlcmF0aW9uLCBhbmQgQidzIHBhdGggaW50ZXJzZWN0cyBleGFjdGx5IHdpdGggb25lXG4gICAgLy8gb2YgQSdzIHBhdGhzLCBvbmUgb2YgdGhlIGpvaW4gdGFyZ2V0cyB3YXMgYWxyZWFkeSByZW1vdmVkLCBzbyByZW1vdmUgdGhlXG4gICAgLy8gb3RoZXIgb25lIGFzIHdlbGwuXG4gICAgaWYgKFxuICAgICAgKGEudHlwZSA9PSAnam9pbl9ub2RlJykgJiZcbiAgICAgIChhcF9icCA9PSAnZXhhY3QnIHx8IGF3cF9icCA9PSAnZXhhY3QnKVxuICAgICkge1xuICAgICAgY29uc3QgcGF0aCA9IGFwX2JwID09ICdleGFjdCcgPyBhLndpdGhQYXRoLnNsaWNlKCkgOiBhLnBhdGguc2xpY2UoKVxuICAgICAgY29uc3QgcmVtb3ZlID0geyB0eXBlOiAncmVtb3ZlX25vZGUnLCBwYXRoIH1cbiAgICAgIHJldHVybiBbcmVtb3ZlXVxuICAgIH1cblxuICAgIC8vIElmIEIncyBwYXRoIGludGVyc2VjdHMgZXhhY3RseSBhdCBBJ3MgcGF0aCwgYW5kIG9wZXJhdGlvbiBBIGlzIG5vdCBhblxuICAgIC8vIGBpbnNlcnRfbm9kZWAgb3BlcmF0aW9uLCBpZ25vcmUgb3BlcmF0aW9uIEEgYmVjYXVzZSB0aGUgbm9kZSBpdCBpc1xuICAgIC8vIHRhcmdldGluZyBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQuXG4gICAgaWYgKGEudHlwZSAhPSAnaW5zZXJ0X25vZGUnICYmIGFwX2JwID09ICdleGFjdCcpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLy8gSWYgQidzIHBhdGggaW50ZXJzZWN0cyBhYm92ZSBvZiBBJ3MsIGlnbm9yZSBvcGVyYXRpb24gQSBiZWNhdXNlIHRoZVxuICAgIC8vIHRhcmdldCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQuXG4gICAgaWYgKGFwX2JwID09ICdhYm92ZScpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLy8gSWYgQidzIHBhdGggaW50ZXJzZWN0cyBiZWZvcmUgQSdzLCBkZWNyZW1lbnQgQSdzIHRvIGFjY291bnQgZm9yIHRoZVxuICAgIC8vIGVhcmxpZXIgbm9kZSdzIHJlbW92YWwuXG4gICAgaWYgKGFwX2JwID09ICdiZWZvcmUnKSB7XG4gICAgICBhLnBhdGhbaV0tLVxuICAgICAgaWYgKGEud2l0aFBhdGgpIGEud2l0aFBhdGhbaV0tLVxuICAgIH1cblxuICAgIC8vIElmIEIncyBwYXRoIGludGVyc2VjdHMgYmVmb3JlIEEncyBgbmV3UGF0aGAsIGRlY3JlbWVudCBBJ3MgYG5ld1BhdGhgIHRvXG4gICAgLy8gYWNjb3VudCBmb3IgdGhlIGVhcmxpZXIgbm9kZSdzIHJlbW92YWwuXG4gICAgaWYgKGFucF9icCA9PSAnYmVmb3JlJykge1xuICAgICAgYS5uZXdQYXRoW2ldLS1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSm9pbiBub2RlLlxuICAgKi9cblxuICBpZiAoYi50eXBlID09ICdqb2luX25vZGUnKSB7XG4gICAgLy8gSWYgQSBpcyBhIGBqb2luX25vZGVgIG9wZXJhdGlvbiwgYW5kIEIncyBwYXRoIGludGVyc2VjdHMgQSdzIHBhdGhcbiAgICAvLyBleGFjdGx5LCB0aGVuIGlnbm9yZSBvcGVyYXRpb24gQS5cbiAgICBpZiAoYS50eXBlID09ICdqb2luX25vZGUnICYmIGFwX2JwID09ICdleGFjdCcpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLy8gSWYgQSBpcyBhbiBgaW5zZXJ0X25vZGVgIG9wZXJhdGlvbiwgYW5kIEIncyBwYXRoIGludGVyc2VjdHMgZXhhY3RseSB3aXRoXG4gICAgLy8gQSdzLCBkbyBub3RoaW5nLCBiZWNhdXNlIHRoZSBpbnNlcnQgcGF0aCB3b24ndCBiZSBhZmZlY3RlZC5cbiAgICBpZiAoYS50eXBlID09ICdpbnNlcnRfbm9kZScgJiYgYXBfYnAgPT0gJ2V4YWN0Jykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgQSBpcyBhIGByZW1vdmVfbm9kZWAgb3BlcmF0aW9uLCBhbmQgQidzIGB3aXRoUGF0aGAgaW50ZXJzZWN0cyB3aXRoXG4gICAgLy8gQSdzLCB0aGVuIHRoZSByZW1vdmFsIHRhcmdldCB3YXMgYWxyZWFkeSBqb2luZWQgd2l0aCBhbm90aGVyIG5vZGUsIGFuZCB3ZVxuICAgIC8vIG5lZWQgdG8gcmVtb3ZlIHRoZSBjb21iaW5lZCByZXN1bHQgbm9kZSBpbnN0ZWFkLlxuICAgIGlmIChhcF9icCA9PSAnZXhhY3QnKSB7XG4gICAgICBhLnBhdGggPSBiLndpdGhQYXRoLnNsaWNlKClcbiAgICB9XG5cbiAgICAvLyBJZiBCJ3MgcGF0aCBpcyBiZWZvcmUgQSdzLCBkZWNyZW1lbnQgQSdzIHRvIGFjY291bnQgZm9yIHRoZSBqb2luLlxuICAgIGlmIChcbiAgICAgIChhcF9icCA9PSAnYmVmb3JlJykgfHxcbiAgICAgIChhcF9icCA9PSAnYWJvdmUnKVxuICAgICkge1xuICAgICAgYS5wYXRoW2ldLS1cbiAgICAgIGlmIChhLndpdGhQYXRoKSBhLndpdGhQYXRoW2ldLS1cbiAgICB9XG5cbiAgICAvLyBJZiBCJ3MgcGF0aCBpcyBiZWZvcmUgQSdzIGBuZXdQYXRoYCwgZGVjcmVtZW50IEEncyBgbmV3UGF0aGAgdG8gYWNjb3VudFxuICAgIC8vIGZvciB0aGUgam9pbi5cbiAgICBpZiAoXG4gICAgICAoYW5wX2JwID09ICdiZWZvcmUnKSB8fFxuICAgICAgKGFucF9icCA9PSAnYWJvdmUnKVxuICAgICkge1xuICAgICAgYS5uZXdQYXRoW2ldLS1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IHRleHQuXG4gICAqL1xuXG4gIGlmIChiLnR5cGUgPT0gJ2luc2VydF90ZXh0Jykge1xuICAgIC8vIElmIG9wZXJhdGlvbiBCJ3MgcGF0aCBkb2Vzbid0IGV4YWN0bHkgaW50ZXJzZWN0IHdpdGggQSdzLCB0aGVuIHRoZSB0ZXh0XG4gICAgLy8gaW5zZXJ0aW9uIHdvbid0IGhhdmUgYW55IGVmZmVjdCBvbiBpdC5cbiAgICBpZiAoYXBfYnAgIT0gJ2V4YWN0Jykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgQSBpcyBhbiBvcGVyYXRpb24gd2l0aCBhbiBgb2Zmc2V0YCwgYnV0IG5vdCBhbiBgaW5zZXJ0X3RleHRgXG4gICAgLy8gb3BlcmF0aW9uLCBhbmQgQidzIGBvZmZzZXRgIGludGVyc2VjdHMgYWZ0ZXIgaXQsIGFuZCBCJ3MgYG9mZnNldGAgaXMgbGVzc1xuICAgIC8vIHRoYW4gQSdzIHJhbmdlLCBBJ3MgcmFuZ2Ugd2lsbCBiZSBzcGxpdCB3aGVyZSBCIGludGVyc2VjdHMgaXRcbiAgICAvLyBpbnRvIHR3byBvcGVyYXRpb25zLlxuICAgIGlmIChcbiAgICAgIChhb19ibyA9PSAnYWZ0ZXInKSAmJlxuICAgICAgKGEudHlwZSAhPSAnaW5zZXJ0X3RleHQnKSAmJlxuICAgICAgKGIub2Zmc2V0IDwgYS5vZmZzZXQgKyBhLmxlbmd0aClcbiAgICApIHtcbiAgICAgIGNvbnN0IG9uZSA9IHsgLi4uYSwgbGVuZ3RoOiBiLm9mZnNldCB9XG4gICAgICBjb25zdCB0d28gPSB7IC4uLmEsIG9mZnNldDogYi5vZmZzZXQgKyBiLnRleHQubGVuZ3RoLCBsZW5ndGg6IGEubGVuZ3RoIC0gYi5vZmZzZXQgfVxuICAgICAgcmV0dXJuIFtvbmUsIHR3b11cbiAgICB9XG5cbiAgICAvLyBJZiBCJ3Mgb2Zmc2V0IGludGVyc2VjdHMgYmVmb3JlIEEncywgb3IgYXQgdGhlIHNhbWUgaW5kZXggYXMgQSdzIGJ1dCB3aXRoXG4gICAgLy8gcHJpb3JpdHksIG9yIGV4YWN0bHkgYXQgQSdzIGJ1dCBBIGlzIG5vdCBhbiBgaW5zZXJ0X3RleHRgIG9wZXJhdGlvbixcbiAgICAvLyBpbmNyZW1lbnQgQSdzIG9mZnNldCB0byBhY2NvdW50IGZvciB0aGUgaW5zZXJ0ZWQgdGV4dC5cbiAgICBpZiAoXG4gICAgICAoYW9fYm8gPT0gJ2JlZm9yZScpIHx8XG4gICAgICAoYW9fYm8gPT0gJ2V4YWN0JyAmJiBwID09ICdyaWdodCcpIHx8XG4gICAgICAoYW9fYm8gPT0gJ2V4YWN0JyAmJiBhLnR5cGUgIT0gJ2luc2VydF90ZXh0JylcbiAgICApIHtcbiAgICAgIGEub2Zmc2V0ICs9IGIudGV4dC5sZW5ndGhcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRleHQuXG4gICAqL1xuXG4gIGlmIChiLnR5cGUgPT0gJ3JlbW92ZV90ZXh0Jykge1xuICAgIC8vIElmIG9wZXJhdGlvbiBCJ3MgcGF0aCBkb2Vzbid0IGV4YWN0bHkgaW50ZXJzZWN0IHdpdGggQSdzLCB0aGVuIHRoZSB0ZXh0XG4gICAgLy8gcmVtb3ZhbCB3b24ndCBoYXZlIGFueSBlZmZlY3Qgb24gaXQuXG4gICAgaWYgKGFwX2JwICE9ICdleGFjdCcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIEEgaXMgYW4gYGluc2VydF90ZXh0YCBvcGVyYXRpb24sIGFuZCBpZiBCJ3Mgb2Zmc2V0IGludGVyc2VjdHMgYmVmb3Jlc1xuICAgIC8vIEEncywgZGVjcmVtZW50IEEncyBvZmZzZXQgdG8gYWNjb3VudCBmb3IgdGhlIHJlbW92ZWQgdGV4dC5cbiAgICBpZiAoYS50eXBlID09ICdpbnNlcnRfdGV4dCcgJiYgYW9fYm8gPT0gJ2JlZm9yZScpIHtcbiAgICAgIGNvbnN0IHJlbW92ZSA9IE1hdGgubWluKGEub2Zmc2V0LCBiLmxlbmd0aClcbiAgICAgIGEub2Zmc2V0IC09IHJlbW92ZVxuICAgIH1cblxuICAgIC8vIElmIEEgaXMgbm90IGFuIGBpbnNlcnRfdGV4dGAgb3BlcmF0aW9uLCBhbmQgQidzIGBvZmZzZXRgIGludGVyc2VjdHNcbiAgICAvLyBiZWZvcmUgQSdzIGBvZmZzZXRgLCBkZWNyZW1lbnQgQSdzIGBvZmZzZXRgIGJ5IHRoZSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuICAgIC8vIHJlbW92ZWQgYmVmb3JlIGl0LCBhbmQgQSdzIGBsZW5ndGhgIGJ5IHRoZSBjaGFyYWN0ZXJzIHJlbW92ZWQgdGhhdFxuICAgIC8vIG92ZXJsYXAgaXQuXG4gICAgaWYgKGEudHlwZSAhPSAnaW5zZXJ0X3RleHQnICYmIGFvX2JvID09ICdiZWZvcmUnKSB7XG4gICAgICBjb25zdCBkZWNyZW1lbnQgPSBNYXRoLm1pbihiLmxlbmd0aCwgYS5vZmZzZXQgLSBiLm9mZnNldClcbiAgICAgIGNvbnN0IHJlbW92ZSA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCAtIGRlY3JlbWVudClcbiAgICAgIGEub2Zmc2V0IC09IGRlY3JlbWVudFxuICAgICAgYS5sZW5ndGggLT0gcmVtb3ZlXG4gICAgfVxuXG4gICAgLy8gSWYgQSBpcyBub3QgYW4gYGluc2VydF90ZXh0YCBvcGVyYXRpb24sIGFuZCBCIGludGVyc2VjdHMgaXMgZXhhY3RseSxcbiAgICAvLyBkZWNyZW1lbnQgQSdzIGBsZW5ndGhgIGJ5IEIncyBgbGVuZ3RoYCBzaW5jZSB0aGF0IHRleHQgaXMgYWxyZWFkeVxuICAgIC8vIHJlbW92ZWQuXG4gICAgaWYgKGEudHlwZSAhPSAnaW5zZXJ0X3RleHQnICYmIGFvX2JvID09ICdleGFjdCcpIHtcbiAgICAgIGNvbnN0IHJlbW92ZSA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgICAgIGEubGVuZ3RoIC09IHJlbW92ZVxuICAgIH1cblxuICAgIC8vIElmIEEgaXMgbm90IGFuIGBpbnNlcnRfdGV4dGAgb3BlcmF0aW9uLCBhbmQgQidzIGBvZmZzZXRgIGludGVyc2VjdHMgYWZ0ZXJcbiAgICAvLyBBJ3MgYG9mZnNldGAsIGRlY3JlbWVudCBBJ3MgYGxlbmd0aGAgYnkgYW55IG92ZXJsYXBwaW5nIGNoYXJhY3RlcnMgdGhhdFxuICAgIC8vIGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQuXG4gICAgaWYgKGEudHlwZSAhPSAnaW5zZXJ0X3RleHQnICYmIGFvX2JvID09ICdhZnRlcicpIHtcbiAgICAgIGNvbnN0IGRpZmYgPSBiLm9mZnNldCAtIGEub2Zmc2V0XG4gICAgICBjb25zdCBvdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYi5sZW5ndGgsIGEubGVuZ3RoIC0gZGlmZikpXG4gICAgICBjb25zdCByZW1vdmUgPSBNYXRoLm1pbihhLmxlbmd0aCwgb3ZlcmxhcClcbiAgICAgIGEubGVuZ3RoIC09IHJlbW92ZVxuICAgIH1cblxuICAgIC8vIElmIEEgaXMgbm90IGFuIGBpbnNlcnRfdGV4dGAgb3BlcmF0aW9uLCBhbmQgYWZ0ZXIgYWRqdXN0aW5nIEEncyBgb2Zmc2V0YFxuICAgIC8vIGFuZCBgbGVuZ3RoYCwgaXRzIGBsZW5ndGhgIGlzIHplcm8sIGlnbm9yZSBBIHNpbmNlIGl0IGRvZXMgbm90aGluZy5cbiAgICBpZiAoYS50eXBlICE9ICdpbnNlcnRfdGV4dCcgJiYgYW9fYm8gIT0gbnVsbCAmJiBhLmxlbmd0aCA9PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbWFyay5cbiAgICovXG5cbiAgaWYgKGIudHlwZSA9PSAnYWRkX21hcmsnKSB7XG4gICAgLy8gSWYgQidzIHBhdGggZG9lc24ndCBpbnRlcnNlY3QgQSdzIGV4YWN0bHksIG9yIGVpdGhlciBvcGVyYXRpb24gaGFzIG5vXG4gICAgLy8gYG9mZnNldGAsIG9yIEIgZG9lc24ndCBoYXZlIHByaW9yaXR5LCBvciB0aGUgb3BlcmF0aW9ucydzIGBtYXJrYCBkb24ndFxuICAgIC8vIG1hdGNoLCB0aGVuIEIgY2FuJ3QgYWZmZWN0IEEsIHNvIGFib3J0LlxuICAgIGlmIChcbiAgICAgIGFwX2JwICE9ICdleGFjdCcgfHxcbiAgICAgIGFvX2JvID09IG51bGwgfHxcbiAgICAgIHAgIT0gJ3JpZ2h0JyB8fFxuICAgICAgIWlzRXF1YWwoYS5tYXJrLCBiLm1hcmspXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiBBIGlzIGFuIGByZW1vdmVfbWFya2Agb3BlcmF0aW9uLCBhbmQgQidzIHN0YXJ0IGludGVyc2VjdHMgYmVmb3JlIEEncyxcbiAgICAvLyBzaGlmdCBBIHRvIG9taXQgdGhlIHJhbmdlIHJlbW92ZWQgYnkgQi5cbiAgICBpZiAoYS50eXBlID09ICdyZW1vdmVfbWFyaycgJiYgYW9fYm8gPT0gJ2JlZm9yZScpIHtcbiAgICAgIGNvbnN0IHNraXAgPSBNYXRoLm1pbihiLmxlbmd0aCwgYS5vZmZzZXQgLSBiLm9mZnNldClcbiAgICAgIGNvbnN0IG9taXQgPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGggLSBza2lwKVxuICAgICAgYS5vZmZzZXQgKz0gc2tpcFxuICAgICAgYS5sZW5ndGggLT0gb21pdFxuICAgIH1cblxuICAgIC8vIElmIEEgaXMgYW4gYHJlbW92ZV9tYXJrYCBvcGVyYXRpb24sIGFuZCBCJ3Mgc3RhcnQgaW50ZXJzZWN0cyBleGFjdGx5IGF0XG4gICAgLy8gQSdzLCBzaGlmdCBBIHRvIG9taXQgdGhlIHJhbmdlIHJlbW92ZWQgYnkgQi5cbiAgICBpZiAoYS50eXBlID09ICdyZW1vdmVfbWFyaycgJiYgYW9fYm8gPT0gJ2V4YWN0Jykge1xuICAgICAgY29uc3Qgb21pdCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgICAgIGEub2Zmc2V0ICs9IG9taXRcbiAgICAgIGEubGVuZ3RoIC09IG9taXRcbiAgICB9XG5cbiAgICAvLyBJZiBBIGlzIGFuIGByZW1vdmVfbWFya2Agb3BlcmF0aW9uLCBhbmQgQidzIHN0YXJ0IGludGVyc2VjdHMgYWZ0ZXIgQSdzLFxuICAgIC8vIGFuZCBCJ3MgZW5kIGludGVyc2VjdHMgYmVmb3JlIEEncywgd2UgbmVlZCB0byBzcGxpdCBBIGludG8gdHdvIG9wZXJhdGlvbnNcbiAgICAvLyBzaW5jZSBCIHJlbW92ZXMgdGhlIG1hcmsgaW4gdGhlIG1pZGRsZS5cbiAgICBpZiAoYS50eXBlID09ICdyZW1vdmVfbWFyaycgJiYgYW9fYm8gPT0gJ2FmdGVyJyAmJiBhb2xfYm9sID09ICdiZWZvcmUnKSB7XG4gICAgICBjb25zdCBiZWZvcmUgPSBiLm9mZnNldCAtIGEub2Zmc2V0XG4gICAgICBjb25zdCBhZnRlciA9IGEubGVuZ3RoIC0gYmVmb3JlIC0gYi5sZW5ndGhcbiAgICAgIGNvbnN0IG1pZGRsZSA9IGEubGVuZ3RoIC0gYmVmb3JlIC0gYWZ0ZXJcbiAgICAgIGNvbnN0IG9uZSA9IHsgLi4uYSwgbGVuZ3RoOiBiZWZvcmUgfVxuICAgICAgY29uc3QgdHdvID0geyAuLi5hLCBvZmZzZXQ6IGEub2Zmc2V0ICsgYmVmb3JlICsgbWlkZGxlLCBsZW5ndGg6IGFmdGVyIH1cbiAgICAgIHJldHVybiBbb25lLCB0d29dXG4gICAgfVxuXG4gICAgLy8gSWYgQSBpcyBhbiBgcmVtb3ZlX21hcmtgIG9wZXJhdGlvbiwgYW5kIEIncyBzdGFydCBpbnRlcnNlY3RzIGFmdGVyIEEncyxcbiAgICAvLyByZW1vdmUgdGhlIG92ZXJsYXBpbmcgcmVnaW9uIGZyb20gQS5cbiAgICBpZiAoYS50eXBlID09ICdyZW1vdmVfbWFyaycgJiYgYW9fYm8gPT0gJ2FmdGVyJykge1xuICAgICAgY29uc3QgZGlmZiA9IGIub2Zmc2V0IC0gYS5vZmZzZXRcbiAgICAgIGNvbnN0IG92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihiLmxlbmd0aCwgYS5sZW5ndGggLSBkaWZmKSlcbiAgICAgIGNvbnN0IHJlbW92ZSA9IE1hdGgubWluKGEubGVuZ3RoLCBvdmVybGFwKVxuICAgICAgYS5sZW5ndGggLT0gcmVtb3ZlXG4gICAgfVxuXG4gICAgLy8gSWYgQSBpcyBhbiBgcmVtb3ZlX21hcmtgIG9wZXJhdGlvbiwgYW5kIGl0cyBgbGVuZ3RoYCBpcyBub3cgemVybywgcmVtb3ZlXG4gICAgLy8gaXQgYmVjYXVzZSBpdCB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICAgIGlmIChhLnR5cGUgPT0gJ3JlbW92ZV9tYXJrJyAmJiBhLmxlbmd0aCA9PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgbWFyay5cbiAgICovXG5cbiAgaWYgKGIudHlwZSA9PSAncmVtb3ZlX21hcmsnKSB7XG4gICAgLy8gSWYgQidzIHBhdGggZG9lc24ndCBpbnRlcnNlY3QgQSdzIGV4YWN0bHksIG9yIGVpdGhlciBvcGVyYXRpb24gaGFzIG5vXG4gICAgLy8gYG9mZnNldGAsIG9yIEIgZG9lc24ndCBoYXZlIHByaW9yaXR5LCBvciB0aGUgb3BlcmF0aW9ucydzIGBtYXJrYCBkb24ndFxuICAgIC8vIG1hdGNoLCB0aGVuIEIgY2FuJ3QgYWZmZWN0IEEsIHNvIGFib3J0LlxuICAgIGlmIChcbiAgICAgIGFwX2JwICE9ICdleGFjdCcgfHxcbiAgICAgIGFvX2JvID09IG51bGwgfHxcbiAgICAgIHAgIT0gJ3JpZ2h0JyB8fFxuICAgICAgIWlzRXF1YWwoYS5tYXJrLCBiLm1hcmspXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiBBIGlzIGFuIGBhZGRfbWFya2Agb3BlcmF0aW9uLCBhbmQgQidzIHN0YXJ0IGludGVyc2VjdHMgYmVmb3JlIEEncyxcbiAgICAvLyBzaGlmdCBBIHRvIG9taXQgdGhlIHJhbmdlIHJlbW92ZWQgYnkgQi5cbiAgICBpZiAoYS50eXBlID09ICdhZGRfbWFyaycgJiYgYW9fYm8gPT0gJ2JlZm9yZScpIHtcbiAgICAgIGNvbnN0IHNraXAgPSBNYXRoLm1pbihiLmxlbmd0aCwgYS5vZmZzZXQgLSBiLm9mZnNldClcbiAgICAgIGNvbnN0IG9taXQgPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGggLSBza2lwKVxuICAgICAgYS5vZmZzZXQgKz0gc2tpcFxuICAgICAgYS5sZW5ndGggLT0gb21pdFxuICAgIH1cblxuICAgIC8vIElmIEEgaXMgYW4gYGFkZF9tYXJrYCBvcGVyYXRpb24sIGFuZCBCJ3Mgc3RhcnQgaW50ZXJzZWN0cyBleGFjdGx5IGF0IEEncyxcbiAgICAvLyBzaGlmdCBBIHRvIG9taXQgdGhlIHJhbmdlIHJlbW92ZWQgYnkgQi5cbiAgICBpZiAoYS50eXBlID09ICdhZGRfbWFyaycgJiYgYW9fYm8gPT0gJ2V4YWN0Jykge1xuICAgICAgY29uc3Qgb21pdCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgICAgIGEub2Zmc2V0ICs9IG9taXRcbiAgICAgIGEubGVuZ3RoIC09IG9taXRcbiAgICB9XG5cbiAgICAvLyBJZiBBIGlzIGFuIGBhZGRfbWFya2Agb3BlcmF0aW9uLCBhbmQgQidzIHN0YXJ0IGludGVyc2VjdHMgYWZ0ZXIgQSdzLFxuICAgIC8vIGFuZCBCJ3MgZW5kIGludGVyc2VjdHMgYmVmb3JlIEEncywgd2UgbmVlZCB0byBzcGxpdCBBIGludG8gdHdvIG9wZXJhdGlvbnNcbiAgICAvLyBzaW5jZSBCIHJlbW92ZXMgdGhlIG1hcmsgaW4gdGhlIG1pZGRsZS5cbiAgICBpZiAoYS50eXBlID09ICdhZGRfbWFyaycgJiYgYW9fYm8gPT0gJ2FmdGVyJyAmJiBhb2xfYm9sID09ICdiZWZvcmUnKSB7XG4gICAgICBjb25zdCBiZWZvcmUgPSBiLm9mZnNldCAtIGEub2Zmc2V0XG4gICAgICBjb25zdCBhZnRlciA9IGEubGVuZ3RoIC0gYmVmb3JlIC0gYi5sZW5ndGhcbiAgICAgIGNvbnN0IG1pZGRsZSA9IGEubGVuZ3RoIC0gYmVmb3JlIC0gYWZ0ZXJcbiAgICAgIGNvbnN0IG9uZSA9IHsgLi4uYSwgbGVuZ3RoOiBiZWZvcmUgfVxuICAgICAgY29uc3QgdHdvID0geyAuLi5hLCBvZmZzZXQ6IGEub2Zmc2V0ICsgYmVmb3JlICsgbWlkZGxlLCBsZW5ndGg6IGFmdGVyIH1cbiAgICAgIHJldHVybiBbb25lLCB0d29dXG4gICAgfVxuXG4gICAgLy8gSWYgQSBpcyBhbiBgYWRkX21hcmtgIG9wZXJhdGlvbiwgYW5kIEIncyBzdGFydCBpbnRlcnNlY3RzIGFmdGVyIEEncyxcbiAgICAvLyByZW1vdmUgdGhlIG92ZXJsYXBpbmcgcmVnaW9uIGZyb20gQS5cbiAgICBpZiAoYS50eXBlID09ICdhZGRfbWFyaycgJiYgYW9fYm8gPT0gJ2FmdGVyJykge1xuICAgICAgY29uc3QgZGlmZiA9IGIub2Zmc2V0IC0gYS5vZmZzZXRcbiAgICAgIGNvbnN0IG92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihiLmxlbmd0aCwgYS5sZW5ndGggLSBkaWZmKSlcbiAgICAgIGNvbnN0IHJlbW92ZSA9IE1hdGgubWluKGEubGVuZ3RoLCBvdmVybGFwKVxuICAgICAgYS5sZW5ndGggLT0gcmVtb3ZlXG4gICAgfVxuXG4gICAgLy8gSWYgQSBpcyBhbiBgYWRkX21hcmtgIG9wZXJhdGlvbiwgYW5kIGl0cyBgbGVuZ3RoYCBpcyBub3cgemVybywgcmVtb3ZlIGl0XG4gICAgLy8gYmVjYXVzZSBpdCB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICAgIGlmIChhLnR5cGUgPT0gJ2FkZF9tYXJrJyAmJiBhLmxlbmd0aCA9PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIG5vZGUuXG4gICAqL1xuXG4gIGlmIChiLnR5cGUgPT0gJ21vdmVfbm9kZScpIHtcbiAgICAvLyBJZiBBIGlzIGFsc28gYSBgbW92ZV9ub2RlYCBvcGVyYXRpb24sIGFuZCB0aGVpciBwYXRocyBhcmUgZXhhY3RseSBlcXVhbCxcbiAgICAvLyBhbmQgQiBoYXMgcHJpb3JpdHksIHRoZW4gcmVtb3ZlIEEgYmVjYXVzZSBpdCBcImxvc3RcIi5cbiAgICBpZiAoYS50eXBlID09ICdtb3ZlX25vZGUnICYmIGFwX2JwID09ICdleGFjdCcgJiYgcCA9PSAncmlnaHQnKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8vIElmIEIncyBvbGQgcGF0aCBpcyBleGFjdGx5IEEncywgY2hhbmdlIEEncyBwYXRoIHRvIHdoZXJlIEIgbW92ZWQgaXQgdG8uXG4gICAgaWYgKGFwX2JwID09ICdleGFjdCcpIHtcbiAgICAgIGEucGF0aCA9IGIubmV3UGF0aFxuICAgIH1cblxuICAgIC8vIElmIEIncyBvbGQgcGF0aCBpcyBleGFjdGx5IEEncyBgbmV3UGF0aGAsIGNoYW5nZSBBJ3MgYG5ld1BhdGhgIHRvIHdoZXJlIEJcbiAgICAvLyBtb3ZlZCBpdCB0by5cbiAgICBpZiAoYW5wX2JwID09ICdleGFjdCcpIHtcbiAgICAgIGEubmV3UGF0aCA9IGIubmV3UGF0aFxuICAgIH1cblxuICAgIC8vIElmIEIncyBvbGQgcGF0aCBpbnRlcnNlY3RzIGFib3ZlIEEncywgY2hhbmdlIEEncyBwYXRoIHRvIHJlZmxlY3Qgd2hlcmUgQlxuICAgIC8vIG1vdmVkIGl0IHRvLlxuICAgIGlmIChhcF9icCA9PSAnYWJvdmUnKSB7XG4gICAgICBhLnBhdGggPSBiLm5ld1BhdGguY29uY2F0KGEucGF0aC5zbGljZShiLm5ld1BhdGgubGVuZ3RoKSlcbiAgICB9XG5cbiAgICAvLyBJZiBCJ3Mgb2xkIHBhdGggaW50ZXJzZWN0cyBhYm92ZSBBJ3MgYG5ld1BhdGhgLCBjaGFuZ2UgQSdzIGBuZXdQYXRoYCB0b1xuICAgIC8vIHJlZmxlY3Qgd2hlcmUgQiBtb3ZlZCBpdCB0by5cbiAgICBpZiAoYW5wX2JwID09ICdhYm92ZScpIHtcbiAgICAgIGEubmV3UGF0aCA9IGIubmV3UGF0aC5jb25jYXQoYS5uZXdQYXRoLnNsaWNlKGIubmV3UGF0aC5sZW5ndGgpKVxuICAgIH1cblxuICAgIC8vIElmIEIncyBvbGQgcGF0aCBpbnRlcnNlY3RzIGJlZm9yZSBBJ3MsIGFuZCBpdHMgbmV3IHBhdGggaW50ZXJlY3RzIGFmdGVyXG4gICAgLy8gb3IgZXhhY3RseSBhdCBBJ3MsIGRlY3JlbWVudCBBJ3MgcGF0aCB0byBhY2NvdW50IGZvciB0aGUgbW92ZS5cbiAgICBpZiAoXG4gICAgICAoYXBfYnAgPT0gJ2JlZm9yZScpICYmXG4gICAgICAoYXBfYm5wID09ICdub25lJyB8fCBhcF9ibnAgPT0gJ2V4YWN0JyB8fCBhcF9ibnAgPT0gJ2Fib3ZlJylcbiAgICApIHtcbiAgICAgIGEucGF0aFtpXS0tXG4gICAgICBpZiAoYS53aXRoUGF0aCkgYS53aXRoUGF0aFtpXS0tXG4gICAgfVxuXG4gICAgLy8gSWYgQidzIG9sZCBwYXRoIGludGVyc2VjdHMgYmVmb3JlIEEncyBgbmV3UGF0aGAsIGFuZCBCJ3MgYG5ld1BhdGhgXG4gICAgLy8gaW50ZXJlY3RzIGFmdGVyIG9yIGV4YWN0bHkgYXQgQSdzIGBuZXdQYXRoYCwgZGVjcmVtZW50IEEncyBgbmV3UGF0aGAgdG9cbiAgICAvLyBhY2NvdW50IGZvciB0aGUgbW92ZS5cbiAgICBpZiAoXG4gICAgICAoYW5wX2JwID09ICdiZWZvcmUnKSAmJlxuICAgICAgKGFwX2JwICE9ICdleGFjdCcpICYmXG4gICAgICAoYW5wX2JucCA9PSAnbm9uZScgfHwgYW5wX2JucCA9PSAnZXhhY3QnIHx8IGFucF9ibnAgPT0gJ2Fib3ZlJylcbiAgICApIHtcbiAgICAgIGEubmV3UGF0aFtpXS0tXG4gICAgfVxuXG4gICAgLy8gSWYgQidzIG9sZCBwYXRoIGludGVyc2VjdHMgYmVmb3JlIEEncywgYW5kIGl0cyBuZXcgcGF0aCBpbnRlcnNlY3RzIGJlZm9yZVxuICAgIC8vIG9yIGV4YWN0bHkgYXQgQSdzLCBpbmNyZW1lbnQgQSdzIHBhdGggdG8gYWNjb3VudCBmb3IgdGhlIG1vdmUuXG4gICAgaWYgKFxuICAgICAgKGFwX2JwID09ICdub25lJykgJiZcbiAgICAgIChhcF9ibnAgPT0gJ2JlZm9yZScgfHwgYXBfYm5wID09ICdleGFjdCcgfHwgYW5wX2JucCA9PSAnYWJvdmUnKVxuICAgICkge1xuICAgICAgYS5wYXRoW25pXSsrXG4gICAgICBpZiAoYS53aXRoUGF0aCkgYS53aXRoUGF0aFtuaV0rK1xuICAgIH1cblxuICAgIC8vIElmIEIncyBvbGQgcGF0aCBpbnRlcnNlY3RzIGJlZm9yZSBBJ3MgYG5ld1BhdGhgLCBhbmQgQidzIGBuZXdQYXRoYFxuICAgIC8vIGludGVyc2VjdHMgYmVmb3JlIG9yIGV4YWN0bHkgYXQgQSdzIGBuZXdQYXRoYCwgaW5jcmVtZW50IEEncyBgbmV3UGF0aGAgdG9cbiAgICAvLyBhY2NvdW50IGZvciB0aGUgbW92ZS5cbiAgICBpZiAoXG4gICAgICAoYW5wX2JwID09ICdub25lJykgJiZcbiAgICAgIChhbnBfYm5wID09ICdiZWZvcmUnIHx8IGFucF9ibnAgPT0gJ2V4YWN0JyB8fCBhbnBfYm5wID09ICdhYm92ZScpXG4gICAgKSB7XG4gICAgICBhLm5ld1BhdGhbbmldKytcbiAgICB9XG5cbiAgICByZXR1cm5cblxuICAgIC8vIElmIEEgaXMgYSBgam9pbl9ub2RlYCBvcGVyYXRpb24sIGFuZCBCJ3MgcGF0aCBpbnRlcnNlY3RlZCBlaXRoZXIgb25lIG9mXG4gICAgLy8gQSdzIHBhdGhzLCB0aGVuIGlnbm9yZSBBIHNpbmNlIHRoZSBub2RlcyBhcmUgbm8gbG9uZ2VyIGFkamFjZW50LlxuICAgIGlmIChcbiAgICAgIChhLnR5cGUgPT0gJ2pvaW5fbm9kZScpICYmXG4gICAgICAoYXBfYnAgPT0gJ2V4YWN0JyB8fCBhd3BfYnAgPT0gJ2V4YWN0JykgJiZcbiAgICAgIChwID09ICdyaWdodCcpXG4gICAgKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8vIElmIEEgaGFzIGEgYG5ld1BhdGhgLCBhbmQgYGIucGF0aGAgaW50ZXJzZWN0cyBhdCBgYS5wYXRoYCwgYW5kIGBiYCBoYXNcbiAgICAvLyBwcmlvcml0eSwgYW5kIGBiLm5ld1BhdGhgIGRvZXNuJ3QgaW50ZXJzZWN0LCBkZWNyZW1lbnQuXG4gICAgaWYgKGFucF9icCA9PSAnZXhhY3QnICYmIHAgPT0gJ3JpZ2h0JyAmJiBhbnBfYm5wID09ICdub25lJykge1xuICAgICAgYS5uZXdQYXRoW2ldLS1cbiAgICB9XG4gIH1cblxuICAvLyAvKipcbiAgLy8gICogU3BsaXQgbm9kZS5cbiAgLy8gICovXG5cbiAgLy8gaWYgKGIudHlwZSA9PSAnc3BsaXRfbm9kZScpIHtcbiAgLy8gICAvLyBJZiBgYi5wYXRoYCBpbnRlcnNlY3RzIGJlZm9yZSBgYS5wYXRoYCwgaW5jcmVtZW50LlxuICAvLyAgIGlmIChhcF9icCA9PSAnYmVmb3JlJykge1xuICAvLyAgICAgYS5wYXRoW2ldKytcbiAgLy8gICAgIGlmIChhLndpdGhQYXRoKSBhLndpdGhQYXRoW2ldKytcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBJZiBgYi5wYXRoYCBpbnRlcnNlY3RzIGF0IGBhLnBhdGhgLCBhbmQgYGJgIGhhcyBwcmlvcml0eSwgYW5kIGBhYCBpcyBhXG4gIC8vICAgLy8gYHJlbW92ZV9ub2RlYCBvcGVyYXRpb24sIHRoZW4gaWdub3JlIGBhYC5cbiAgLy8gICBpZiAoYS50eXBlID09ICdyZW1vdmVfbm9kZScgJiYgYXBfYnAgPT0gJ3NhbWUnICYmIHAgPT0gJ3JpZ2h0Jykge1xuICAvLyAgICAgcmV0dXJuIG51bGxcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBJZiBgYi5wYXRoYCBpbnRlcnNlY3RzIGF0IGBhLnBhdGhgLCBhbmQgYGJgIGhhcyBwcmlvcml0eSwgYW5kIGBhYCBpcyBhXG4gIC8vICAgLy8gYHNwbGl0X25vZGVgIG9wZXJhdGlvbiwgdGhlbiBpbmNyZW1lbnQgYGEucGF0aGAgYW5kIGRlY3JlbWVudCBgYS5vZmZzZXRgLlxuICAvLyAgIGlmIChhLnR5cGUgPT0gJ3NwbGl0X25vZGUnICYmIGFwX2JwID09ICdzYW1lJyAmJiBwID09ICdyaWdodCcpIHtcbiAgLy8gICAgIGEucGF0aFtpXSsrXG4gIC8vICAgICBhLm9mZnNldCAtPSBiLm9mZnNldFxuICAvLyAgIH1cblxuICAvLyAgIC8vIElmIGBiLnBhdGhgIGludGVyc2VjdHMgYXQgYGEucGF0aGAsIGFuZCBgYmAgaGFzIHByaW9yaXR5LCBpbmNyZW1lbnRcbiAgLy8gICAvLyBgYS5wYXRoYC5cbiAgLy8gICBpZiAoYXBfYnAgPT0gJ3NhbWUnICYmIHAgPT0gJ3JpZ2h0Jykge1xuICAvLyAgICAgYS5wYXRoW2ldKytcbiAgLy8gICAgIGlmIChhLndpdGhQYXRoKSBhLndpdGhQYXRoW2ldKytcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBJZiBgYi5wYXRoYCBpbnRlcnNlY3RzIGF0IGBhLnBhdGhgLCBhbmQgYGJgIGhhcyBwcmlvcml0eSwgYW5kIEEgaXMgYVxuICAvLyAgIC8vIGByZW1vdmVfbm9kZWAgb3BlcmF0aW9uLCB0aGVuIGlnbm9yZSBBLlxuICAvLyAgIGlmIChhLnR5cGUgPT0gJ3JlbW92ZV9ub2RlJyAmJiBhd3BfYnAgPT0gJ3NhbWUnICYmIHAgPT0gJ3JpZ2h0Jykge1xuICAvLyAgICAgcmV0dXJuIG51bGxcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBJZiBBIGhhcyBhIGBuZXdQYXRoYCwgYW5kIGBiLnBhdGhgIGludGVyc2VjdHMgYmVmb3JlIGBhLnBhdGhgLCBpbmNyZW1lbnQgQSdzXG4gIC8vICAgLy8gcGF0aC5cbiAgLy8gICBpZiAoYW5wX2JwID09ICdiZWZvcmUnKSB7XG4gIC8vICAgICBhLm5ld1BhdGhbaV0rK1xuICAvLyAgIH1cblxuICAvLyAgIC8vIElmIGBiLnBhdGhgIGludGVyc2VjdHMgYXQgYGEubmV3UGF0aGAsIGFuZCBgYmAgaGFzIHByaW9yaXR5LCBpbmNyZW1lbnRcbiAgLy8gICAvLyBgYS5uZXdQYXRoYC5cbiAgLy8gICBpZiAoYW5wX2JwID09ICdzYW1lJyAmJiBwID09ICdyaWdodCcpIHtcbiAgLy8gICAgIGEubmV3UGF0aFtpXSsrXG4gIC8vICAgfVxuICAvLyB9XG59XG5cbi8qKlxuICogRXhwb3J0LlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCB0cmFuc2Zvcm1cbiJdfQ==